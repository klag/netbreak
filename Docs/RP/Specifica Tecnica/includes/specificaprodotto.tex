\newpage
\section{Specifica del prodotto}
In questa sezione verrà descritta in maniera macroscopica l'architettura che verrà adottata nella progettazione. Per semplificare la comprensione, verrà utilizzato un approccio top-down partendo dalle linee generali fino a giungere ad una descrizione in dettaglio delle componenti.

\subsection{Architettura generale}
Il software API Market si caratterizza dalle comuni applicazioni per l'approccio a Microservizi adottato nell'implementazione. In maniera differente da un applicazione monolitica, ogni componente viene realizzato come microservizio a sè stante. L'aggregazione di questi microservizi definisce l'applicazione finale e ne realizza il comportamento definitivo. Esulando dall'approccio a microservizi, il sistema sarà realizzato al pari di una classica applicazione \textit{Client-Server}, dove il lato Front-end (Client) si occuperà di fornire all'utente finale l'interfaccia web su cui poter interagire, mentre il lato Back-end (Server) gestirà e salverà i dati, e si occuperà della gestione delle chiamate API (Tramite l'opportuna componente \textit{API Gateway}). La base di dati utilizzata si occupa della raccolta di dati sensibili dell'utenza, gestione delle applicazioni e chiavi e gestione dei dati statistici.

Il sistema verrà realizzato, per il lato back-end, tramite microservizi con interfaccia Jolie che verranno implementati con codice Java. Questo approccio, sebbene la tematica sia di recente sviluppo, risulta molto gettonato dalle grandi realtà che si sono affacciate a questo approccio (come ad esempio l'AWS Service registry "Eureka" usato dalla piattaforma Netflix). Il lato front-end invece verrà implementato tramite HTML e Javascript, in particolare l'utilizzo del framework full-stack MeteorJS consentirà un binding in real-time per la rappresentazione delle informazioni.
Nella realizzazione dell'API Market richiesto verrà utilizato il desing pattern Model View ViewModel; alcune componenti di questo pattern addotteranno un design patterna microservizi, espresso in due varianti, a catena e di aggregazione.
\begin{figure}
	\centering
	\includegraphics{IMG/MVVMPattern}
	\caption{Il design pattern Model View ViewModel}
\end{figure}

\subsubsection{Pattern architetturale front-end}
Il design pattern Model View ViewModel si compone di tre componenti ed andremo a spiegare brevemente la funzione di ognuna, per poi motivare la scelta di tale pattern.
\begin{itemize}
	\item \textbf{Model}: rappresenta il punto di accesso ai dati, si occupa dell'interazione con essi e ne specifica le modalità di accesso. Nella definizione dell'API Market il model si trova nel Back-end;
	\item \textbf{View}: la view è in grado di gestire eventi, eseguire operazioni ed effettuare il data-binding;
	\item \textbf{ViewModel}: il ViewModel è  il punto di incontro tra la View e il Model: i dati ricevuti da quest’ultimo sono elaborati per essere presentati e passati alla View.
\end{itemize}

In fase di progettazione il gruppo ha preso in esame diversi design pattern architetturali, ma la volontà di realizzare pagine web dinamiche e reattive, unitamente all'uso di tecnologie quali AngularJS e il sistema di comunicazione MeteorJS hanno indirizzato la scelta verso il pattern MVVM.

\paragraph{La componente Model}
Il model è situato nella parte lato server del sistema e svolge le seguenti funzioni:
\begin{itemize}
	\item Interagisce con i database nei quali vengono salvati i dati del sistema, come API, transazioni e profili di utenti. Le funzionalità incluse comprendono microservizi in grado di caricare, salvare, modificare e cancellare dati sui database;
	\item Offre un'interfaccia logica di accesso al ViewModel attraverso la quale richiedere dati e operazioni su di essi, tramite funzionalità del framework Meteor come il Publishing e Subscribing.
\end{itemize}
\paragraph{La componente View}
La componente View è situata nella parte front-end del sistema e ha lo scopo di:
\begin{itemize}
	\item  Rappresentare i dati del ViewModel e non interagisce in nessun modo con essi;
	\item Mostrare le funzionalità offerte all'utente.
\end{itemize} 
La view è una interfaccia web e il gruppo ha scelto di utilizzare CCS3 e HTML5 per le parti statiche, mentre verrà utilizzato AngularJS per le parti dinamiche. 
\paragraph{La componente ViewModel}
il ViewModel è situato nella parte front-end del sistema e comunica sia con la View sia con il Model ed è l'unico componente a conoscere gli altri, realizzando un totale disaccopiamento tra la View e il Model. Il ViewModel ha tre compiti fondamentali, ovvero:
\begin{itemize}
	\item Realizzare il data-binding;
	\item Passare gli input della View e tradurli in azioni Model;
	\item richiedere i dati al Model tramite la tecnica \textit{publish-subscribe} di Meteor e inviarli alla View.
\end{itemize}

\subsubsection{Pattern architetturale back-end}
All'interno del Model sono presenti una serie di microservizi relizzati con il design pattern Aggregator Microservice. 
\begin{figure}[!h]
	\centering
	\includegraphics
	[width=0.7\linewidth]
	{IMG/microservices-aggregator}
	\caption{Aggregator Microservices design pattern}
\end{figure}
Questo design pattern si compone di un aggregatore,ovvero microservizio in grado di collezionare dati che gli vengono forniti da diversi microservizi per  poi renderli fruibili all'utente tramite la View. Utilizzando un design pattern a microservizi è necessario che le varie componenti siano indipendenti tra di loro e quindi anche i relativi database lo sono. La realizzazione di un unico database, avrebbe portato alla realizzazione di una architettura SOA, ovvero una architettura orientata ai servizi. Tutti i microservizi contenuti in un package, sono indipendenti da microservizi contenuti in altri package ed ogni microservizio opera sul database associato.

\subsubsection{Pattern architetturale API Gateway}
Il design pattern architetturale scelto per l'API Gateway è il design pattern a microservizi concatenato. Questo pattern è una sequenza di azioni prestabilite innescate da una richiesta HTTP. 
\begin{figure}[!h]
	\centering
	\includegraphics
	[width=0.7\linewidth]
	{IMG/microservices-chain}
	\caption{Chained Microservice Design Pattern}
\end{figure}
Ogni servizio non può iniziare la sua esecuzione se non è terminato quello precedente. Un punto critico di questa scelta è la lunghezza della catena. L'API Gateway è progettato per elaborare una richiesta e ritornare una risposta al chiamante, quindi si tratta di domande sincrone. Una catena troppo lunga crea una tempo di attesa non indifferente per il client dato che bisogna considerare anche il tempo impiegato dal microservizio target della chiamata all'API Gateway.



